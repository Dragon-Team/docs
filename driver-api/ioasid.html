

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IO Address Space ID &mdash; The Linux-Next Dragon Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux-Next Dragon Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.17-dragon
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux-Next Dragon Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>IO Address Space ID</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/ioasid.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="io-address-space-id">
<h1>IO Address Space ID<a class="headerlink" href="#io-address-space-id" title="Permalink to this headline">¶</a></h1>
<p>IOASID is a generic name for PCIe Process Address ID (PASID) or ARM
SMMU SubstreamID. An IOASID identifies an address space that DMA
requests can target.</p>
<p>The primary use cases for IOASID are Shared Virtual Address (SVA) and
multiple IOVA spaces per device. However, the requirements for IOASID
management can vary among hardware architectures.</p>
<p>For baremetal IOVA, IOASID #0 is used for DMA request without
PASID. Even though some architectures such as VT-d also offers
the flexibility of using any PASIDs for DMA request without PASID.
PASID #0 is reserved and not allocated from any ioasid_set.</p>
<p>Multiple IOVA spaces per device are mapped to auxiliary domains which
can be used for mediated device assignment with and without a virtual
IOMMU (vIOMMU). An IOASID is allocated for each auxiliary domain as default
PASID. Without vIOMMU, default IOASID is used for DMA map/unmap
APIs. With vIOMMU, default IOASID is used for guest IOVA where DMA
request with PASID is required for the device. The reason is that
there is only one PASID #0 per device, e.g. VT-d, RID_PASID is per PCI
device.</p>
<p>This document covers the generic features supported by IOASID
APIs. Vendor-specific use cases are also illustrated with Intel’s VT-d
based platforms as the first example.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#glossary" id="id1">Glossary</a></p></li>
<li><p><a class="reference internal" href="#key-concepts" id="id2">Key Concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#ioasid-set" id="id3">IOASID Set</a></p></li>
<li><p><a class="reference internal" href="#ioasid-set-private-id-spid" id="id4">IOASID Set Private ID (SPID)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ioasid-apis" id="id5">IOASID APIs</a></p>
<ul>
<li><p><a class="reference internal" href="#ioasid-set-level-apis" id="id6">IOASID Set Level APIs</a></p></li>
<li><p><a class="reference internal" href="#individual-ioasid-apis" id="id7">Individual IOASID APIs</a></p></li>
<li><p><a class="reference internal" href="#notifications" id="id8">Notifications</a></p>
<ul>
<li><p><a class="reference internal" href="#events" id="id9">Events</a></p></li>
<li><p><a class="reference internal" href="#ordering" id="id10">Ordering</a></p></li>
<li><p><a class="reference internal" href="#level-sensitivity" id="id11">Level Sensitivity</a></p></li>
<li><p><a class="reference internal" href="#scopes" id="id12">Scopes</a></p></li>
<li><p><a class="reference internal" href="#atomicity" id="id13">Atomicity</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reference-counting" id="id14">Reference counting</a></p></li>
<li><p><a class="reference internal" href="#custom-allocator-apis" id="id15">Custom allocator APIs</a></p>
<ul>
<li><p><a class="reference internal" href="#allocator-choices" id="id16">Allocator Choices</a></p></li>
<li><p><a class="reference internal" href="#namespaces" id="id17">Namespaces</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#life-cycle" id="id18">Life cycle</a></p>
<ul>
<li><p><a class="reference internal" href="#native-ioasid-life-cycle-vt-d-example" id="id19">Native IOASID Life Cycle (VT-d Example)</a></p></li>
<li><p><a class="reference internal" href="#guest-ioasid-life-cycle-vt-d-example" id="id20">Guest IOASID Life Cycle (VT-d Example)</a></p>
<ul>
<li><p><a class="reference internal" href="#kvm-pasid-translation-table-updates" id="id21">KVM PASID Translation Table Updates</a></p></li>
<li><p><a class="reference internal" href="#vdcm-pasid-programming" id="id22">VDCM PASID Programming</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#reference" id="id23">Reference</a></p></li>
</ul>
</div>
<div class="section" id="glossary">
<h2><a class="toc-backref" href="#id1">Glossary</a><a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<p>PASID - Process Address Space ID</p>
<p>IOASID - IO Address Space ID (generic term for PCIe PASID and
SubstreamID in SMMU)</p>
<p>SVA/SVM - Shared Virtual Addressing/Memory</p>
<p>ENQCMD - Intel X86 ISA for efficient workqueue submission [1]
!!!TODO: Link to Spec at the bottom</p>
<p>DSA - Intel Data Streaming Accelerator [2]</p>
<p>VDCM - Virtual Device Composition Module [3]</p>
<p>SIOV - Intel Scalable IO Virtualization</p>
</div>
<div class="section" id="key-concepts">
<h2><a class="toc-backref" href="#id2">Key Concepts</a><a class="headerlink" href="#key-concepts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ioasid-set">
<h3><a class="toc-backref" href="#id3">IOASID Set</a><a class="headerlink" href="#ioasid-set" title="Permalink to this headline">¶</a></h3>
<p>An IOASID set is a group of IOASIDs allocated from the system-wide
IOASID pool. Refer to IOASID set APIs for more details.</p>
<p>IOASID set is particularly useful for guest SVA where each guest could
have its own IOASID set for security and efficiency reasons.</p>
</div>
<div class="section" id="ioasid-set-private-id-spid">
<h3><a class="toc-backref" href="#id4">IOASID Set Private ID (SPID)</a><a class="headerlink" href="#ioasid-set-private-id-spid" title="Permalink to this headline">¶</a></h3>
<p>Each IOASID set has a private namespace of SPIDs. An SPID maps to a
single system-wide IOASID. Conversely, each IOASID may be associated
with an alias ID, local to the IOASID set, named SPID.
SPIDs can be used as guest IOASIDs where each guest could do
IOASID allocation from its own pool and map them to host physical
IOASIDs. SPIDs are particularly useful for supporting live migration
where decoupling guest and host physical resources are necessary.</p>
<p>For example, two VMs can both allocate guest PASID/SPID #101 but map to
different host PASIDs #201 and #202 respectively as shown in the
diagram below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------------.    .------------------.
|   VM 1           |    |   VM 2           |
|                  |    |                  |
|------------------|    |------------------|
| GPASID/SPID 101  |    | GPASID/SPID 101  |
&#39;------------------&#39;    -------------------&#39;     Guest
__________|______________________|____________________
          |                      |               Host
          v                      v
.------------------.    .------------------.
| Host IOASID 201  |    | Host IOASID 202  |
&#39;------------------&#39;    &#39;------------------&#39;
|   IOASID set 1   |    |   IOASID set 2   |
&#39;------------------&#39;    &#39;------------------&#39;
</pre></div>
</div>
<p>Guest PASID is treated as IOASID set private ID (SPID) within an
IOASID set, mappings between guest and host IOASIDs are stored in the
set for inquiry.</p>
</div>
</div>
<div class="section" id="ioasid-apis">
<h2><a class="toc-backref" href="#id5">IOASID APIs</a><a class="headerlink" href="#ioasid-apis" title="Permalink to this headline">¶</a></h2>
<p>To get the IOASID APIs, users must #include &lt;linux/ioasid.h&gt;. These APIs
serve the following functionalities:</p>
<blockquote>
<div><ul class="simple">
<li><p>IOASID allocation/Free</p></li>
<li><p>Group management in the form of ioasid_set</p></li>
<li><p>Private data storage and lookup</p></li>
<li><p>Reference counting</p></li>
<li><p>Event notification in case of a state change</p></li>
</ul>
</div></blockquote>
<div class="section" id="ioasid-set-level-apis">
<h3><a class="toc-backref" href="#id6">IOASID Set Level APIs</a><a class="headerlink" href="#ioasid-set-level-apis" title="Permalink to this headline">¶</a></h3>
<p>For use cases such as guest SVA it is necessary to manage IOASIDs at
ioasid_set level. For example, VMs may allocate multiple IOASIDs for
guest process address sharing (vSVA). It is imperative to enforce
VM-IOASID ownership such that a malicious guest cannot target DMA
traffic outside its own IOASIDs, or free an active IOASID that belongs
to another VM.</p>
<p>The IOASID set APIs serve the following purposes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Ownership/permission enforcement</p></li>
<li><p>Take collective actions, e.g. free an entire set</p></li>
<li><p>Event notifications within a set</p></li>
<li><p>Look up a set based on token</p></li>
<li><p>Quota enforcement</p></li>
</ul>
</div></blockquote>
<p>Each IOASID set is created with a token, which can be one of the
following token types:</p>
<blockquote>
<div><ul class="simple">
<li><p>IOASID_SET_TYPE_NULL (Arbitrary u64 value)</p></li>
<li><p>IOASID_SET_TYPE_MM (Set token is a mm_struct)</p></li>
</ul>
</div></blockquote>
<p>The explicit MM token type is useful when multiple users of an IOASID
set under the same process need to communicate about their shared IOASIDs.
E.g. An IOASID set created by VFIO for one guest can be associated
with the KVM instance for the same guest since they share a common mm_struct.
A token must be unique within its type.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ioasid_set *ioasid_alloc_set(void *token, ioasid_t quota, u32 type)

int ioasid_adjust_set(struct ioasid_set *set, int quota);

void ioasid_set_get(struct ioasid_set *set)

void ioasid_set_put(struct ioasid_set *set)

void ioasid_set_get_locked(struct ioasid_set *set)

void ioasid_set_put_locked(struct ioasid_set *set)

int ioasid_set_for_each_ioasid(struct ioasid_set *set,
                               void (*fn)(ioasid_t id, void *data),
                               void *data)
</pre></div>
</div>
</div>
<div class="section" id="individual-ioasid-apis">
<h3><a class="toc-backref" href="#id7">Individual IOASID APIs</a><a class="headerlink" href="#individual-ioasid-apis" title="Permalink to this headline">¶</a></h3>
<p>Once an ioasid_set is created, IOASIDs can be allocated from the set.
Within the IOASID set namespace, set private ID (SPID) is supported. In
the VM use case, SPID can be used for storing guest PASID.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioasid_t ioasid_alloc(struct ioasid_set *set, ioasid_t min, ioasid_t max,
                      void *private);

int ioasid_get(struct ioasid_set *set, ioasid_t ioasid);

void ioasid_put(struct ioasid_set *set, ioasid_t ioasid);

int ioasid_get_locked(struct ioasid_set *set, ioasid_t ioasid);

void ioasid_put_locked(struct ioasid_set *set, ioasid_t ioasid);

void *ioasid_find(struct ioasid_set *set, ioasid_t ioasid,
                  bool (*getter)(void *));

ioasid_t ioasid_find_by_spid(struct ioasid_set *set, ioasid_t spid)

int ioasid_attach_data(struct ioasid_set *set, ioasid_t ioasid,
                       void *data);
int ioasid_attach_spid(struct ioasid_set *set, ioasid_t ioasid,
                       ioasid_t spid);
</pre></div>
</div>
</div>
<div class="section" id="notifications">
<h3><a class="toc-backref" href="#id8">Notifications</a><a class="headerlink" href="#notifications" title="Permalink to this headline">¶</a></h3>
<p>An IOASID may have multiple users, each user may have hardware context
associated with an IOASID. When the status of an IOASID changes,
e.g. an IOASID is being freed, users need to be notified such that the
associated hardware context can be cleared, flushed, and drained.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ioasid_register_notifier(struct ioasid_set *set, struct
                             notifier_block *nb)

void ioasid_unregister_notifier(struct ioasid_set *set,
                                struct notifier_block *nb)

int ioasid_register_notifier_mm(struct mm_struct *mm, struct
                                notifier_block *nb)

void ioasid_unregister_notifier_mm(struct mm_struct *mm, struct
                                   notifier_block *nb)

int ioasid_notify(ioasid_t ioasid, enum ioasid_notify_val cmd,
                  unsigned int flags)
</pre></div>
</div>
<p>“_mm” flavor of the ioasid_register_notifier() APIs are used when
an IOASID user need to listen to the IOASID events belong to a
process but without the knowledge of the associated ioasid_set.</p>
<div class="section" id="events">
<h4><a class="toc-backref" href="#id9">Events</a><a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h4>
<p>Notification events are pertinent to individual IOASIDs, they can be
one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>ALLOC</p></li>
<li><p>FREE</p></li>
<li><p>BIND</p></li>
<li><p>UNBIND</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="ordering">
<h4><a class="toc-backref" href="#id10">Ordering</a><a class="headerlink" href="#ordering" title="Permalink to this headline">¶</a></h4>
<p>Ordering is supported by IOASID notification priorities as the
following (in ascending order):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum ioasid_notifier_prios {
       IOASID_PRIO_LAST,
       IOASID_PRIO_IOMMU,
       IOASID_PRIO_DEVICE,
       IOASID_PRIO_CPU,
};
</pre></div>
</div>
<p>When registered, notifiers are assigned a priority that affect the
call order. For example, notifiers with CPU priority get called before
notifiers with device priority and so on.</p>
<p>The typical use case is when an IOASID is freed due to an exception, DMA
source should be quiesced before tearing down other hardware contexts
in the system. This will reduce the churn in handling faults. DMA work
submission is performed by the CPU which is granted higher priority than
devices.</p>
</div>
<div class="section" id="level-sensitivity">
<h4><a class="toc-backref" href="#id11">Level Sensitivity</a><a class="headerlink" href="#level-sensitivity" title="Permalink to this headline">¶</a></h4>
<p>For each IOASID state transition, IOASID core ensures that there is
only one notification sent. This resembles level triggered interrupt
where a single interrupt is raised during a state transition.
For example, if ioasid_free() is called twice by a user before the
IOASID is reclaimed, IOASID core will only send out a single
IOASID_NOTIFY_FREE event. Similarly, for IOASID_NOTIFY_BIND/UNBIND
events, which is only sent out once when a SPID is attached/detached.</p>
<p>IOASID notifications cannot be sent directly by IOASID users, they are
sent out by the IOASID core as a by-product of the following APIs:
- ioasid_alloc/free(), emit IOASID_NOTIFY_ALLOC/FREE
- ioasid_attach/detach_spid() emit IOASID_NOTIFY_BIND/UNBIND</p>
</div>
<div class="section" id="scopes">
<h4><a class="toc-backref" href="#id12">Scopes</a><a class="headerlink" href="#scopes" title="Permalink to this headline">¶</a></h4>
<p>There are two types of notifiers in IOASID core: system-wide and
ioasid_set-wide.</p>
<p>System-wide notifier is catering for users that need to handle all the
IOASIDs in the system. E.g. The IOMMU driver.</p>
<p>Per ioasid_set notifier can be used by VM specific components such as
KVM. After all, each KVM instance only cares about IOASIDs within its
own set/guest.</p>
</div>
<div class="section" id="atomicity">
<h4><a class="toc-backref" href="#id13">Atomicity</a><a class="headerlink" href="#atomicity" title="Permalink to this headline">¶</a></h4>
<p>IOASID notifiers are atomic due to spinlocks used inside the IOASID
core. For tasks that cannot be completed in the notifier handler,
async work can be submitted to complete the work later as long as
there is no ordering requirement.</p>
</div>
</div>
<div class="section" id="reference-counting">
<h3><a class="toc-backref" href="#id14">Reference counting</a><a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h3>
<p>IOASID lifecycle management is based on reference counting. Users of
IOASID who intend to align lifecycle with the IOASID need to hold
a reference of the IOASID. The IOASID will not be returned to the pool
for allocation until all references are dropped. Calling ioasid_free()
will mark the IOASID as FREE_PENDING if the IOASID has outstanding
references. No new references can be taken by ioasid_get() once an
IOASID is in the FREE_PENDING state. ioasid_free() can be called
multiple times without an error until all refs are dropped.</p>
<p>ioasid_put() decrements and tests refcount of the IOASID. If refcount
is 0, ioasid will be freed. Deleted from the system-wide xarray as
well as per set xarray. The IOASID will be returned to the pool and
available for new allocations.</p>
<p>Event notifications are used to inform users of IOASID status change.
IOASID_FREE event prompts users to drop their references after
clearing its context.</p>
<p>For example, on VT-d platform when an IOASID is freed, teardown
actions are performed on KVM, device driver (VDCM), and the IOMMU
driver. To quiesce VCPU for work submission, KVM notifier handler must
be called before VDCM handler. Therefore, KVM and VDCM shall use
notification priority IOASID_PRIO_CPU andIOASID_PRIO_DEVICE
respectively.</p>
<p>For both KVM and VDCM, notifier blocks shall be registered on the
IOASID set such that <em>only</em> events from the matching VM are received.</p>
<p>If KVM attempts to register a notifier block before the IOASID set is
created using the MM token, the notifier block will be placed on a
pending list inside IOASID core. Once the token matching IOASID set
is created, IOASID will register the notifier block automatically.
IOASID core does not replay events for the existing IOASIDs in the
set. For IOASID set of MM type, notification blocks can be registered
on empty sets only. This is to avoid lost events.</p>
<p>IOMMU driver shall register notifier block on global chain:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct notifier_block pasid_nb_vtd = {
       .notifier_call = pasid_status_change_vtd,
       .priority      = IOASID_PRIO_IOMMU,
};
</pre></div>
</div>
</div>
<div class="section" id="custom-allocator-apis">
<h3><a class="toc-backref" href="#id15">Custom allocator APIs</a><a class="headerlink" href="#custom-allocator-apis" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ioasid_register_allocator(struct ioasid_allocator_ops *allocator);

void ioasid_unregister_allocator(struct ioasid_allocator_ops *allocator);
</pre></div>
</div>
<div class="section" id="allocator-choices">
<h4><a class="toc-backref" href="#id16">Allocator Choices</a><a class="headerlink" href="#allocator-choices" title="Permalink to this headline">¶</a></h4>
<p>IOASIDs are allocated for both host and guest SVA/IOVA usage. However,
allocators can be different. For example, on VT-d guest PASID
allocation must be performed via a virtual command interface which is
emulated by VMM.</p>
<p>IOASID core has the notion of “custom allocator” such that guest can
register virtual command allocator that precedes the default one.</p>
</div>
<div class="section" id="namespaces">
<h4><a class="toc-backref" href="#id17">Namespaces</a><a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h4>
<p>IOASIDs are limited system resources that default to 20 bits in
size. Each device can have its own PASID table for security reasons.
Theoretically the namespace can be per device also.</p>
<p>However IOASID namespace is system-wide for two reasons:
- Simplicity
- Sharing resources of a single device to multiple VMs.</p>
<p>Take VT-d as an example, VT-d supports shared workqueue and ENQCMD[1]
where one IOASID could be used to submit work on multiple devices that
are shared with other VMs. This requires IOASID to be
system-wide. This is also the reason why guests must use an
emulated virtual command interface to allocate IOASID from the host.</p>
</div>
</div>
</div>
<div class="section" id="life-cycle">
<h2><a class="toc-backref" href="#id18">Life cycle</a><a class="headerlink" href="#life-cycle" title="Permalink to this headline">¶</a></h2>
<p>This section covers IOASID life cycle management for both bare-metal
and guest usages. In bare-metal SVA, MMU notifier is directly hooked
up with IOMMU driver, therefore the IOASID life cycle matches the
process address space (MM) life cycle.</p>
<p>However, guest MMU notifier is not available to host IOMMU driver,
when guest MM terminates unexpectedly, the events have to go through
VFIO and IOMMU UAPI to reach host IOMMU driver. There are also more
parties involved in guest SVA, e.g. on Intel VT-d platform, IOASIDs
are used by IOMMU driver, KVM, VDCM, and VFIO.</p>
<div class="section" id="native-ioasid-life-cycle-vt-d-example">
<h3><a class="toc-backref" href="#id19">Native IOASID Life Cycle (VT-d Example)</a><a class="headerlink" href="#native-ioasid-life-cycle-vt-d-example" title="Permalink to this headline">¶</a></h3>
<p>The normal flow of native SVA code with Intel Data Streaming
Accelerator(DSA) [2] as example:</p>
<ol class="arabic simple">
<li><p>Host user opens accelerator FD, e.g. DSA driver, or uacce;</p></li>
<li><p>DSA driver allocate WQ, do sva_bind_device();</p></li>
<li><p>IOMMU driver calls ioasid_alloc(), then bind PASID with device,
mmu_notifier_get()</p></li>
<li><p>DMA starts by DSA driver userspace</p></li>
<li><p>DSA userspace close FD</p></li>
<li><p>DSA/uacce kernel driver handles FD.close()</p></li>
<li><p>DSA driver stops DMA</p></li>
<li><p>DSA driver calls sva_unbind_device();</p></li>
<li><p>IOMMU driver does unbind, clears PASID context in IOMMU, flush
TLBs. mmu_notifier_put() called.</p></li>
<li><p>mmu_notifier.release() called, IOMMU SVA code calls ioasid_free()*</p></li>
<li><p>The IOASID is returned to the pool, reclaimed.</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* With ENQCMD, PASID used on VT-d is not released in mmu_notifier() but
  mmdrop(). mmdrop comes after FD close which does not make a difference.
</pre></div>
</div>
<p>During the normal teardown, the following three key steps would happen in
order: (7), (9), (11).</p>
<p>Exception happens when process terminates <em>before</em> device driver stops
DMA and call IOMMU driver to unbind. The detailed flow of process
exits are as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>do_exit() {
     exit_mm() {
             mm_put();
             exit_mmap() {
                     intel_invalidate_range() //mmu notifier
                     tlb_finish_mmu()
                     mmu_notifier_release(mm) {
                             intel_mm_release() {
(9)                                  intel_iommu_teardown_pasid();
                                     intel_iommu_flush_tlbs();
                             }
                             // tlb_invalidate_range cb removed
                     }
                     unmap_vmas();
                     free_pgtables(); // IOMMU cannot walk PGT after this
             };
     }
     exit_files(tsk) {
             close_files() {
                     dsa_close();
(7)                  dsa_stop_dma();
                     intel_svm_unbind_pasid(); //nothing to do
             }
     }
}

mmdrop() /* some random time later, lazy mm user */ {
     mm_free_pgd();
     destroy_context(mm); {
(11)         ioasid_free();
     }
}
</pre></div>
</div>
<p>As shown in the list above, step #2 could happen before
#1. Unrecoverable(UR) faults could happen between #2 and #1.
Fault processing is disabled by the IOMMU driver in #2, therefore the UR
fault never reaches the driver.</p>
<p>Also notice that TLB invalidation occurs at mmu_notifier
invalidate_range callback as well as the release callback. The reason
is that release callback will delete IOMMU driver from the notifier
chain which may skip invalidate_range() calls during the exit path.</p>
<p>To avoid unnecessary reporting of UR fault, IOMMU driver shall disable
fault reporting after free and before unbind.</p>
</div>
<div class="section" id="guest-ioasid-life-cycle-vt-d-example">
<h3><a class="toc-backref" href="#id20">Guest IOASID Life Cycle (VT-d Example)</a><a class="headerlink" href="#guest-ioasid-life-cycle-vt-d-example" title="Permalink to this headline">¶</a></h3>
<p>Guest IOASID life cycle starts with guest driver open(), this could be
uacce or individual accelerator driver such as DSA. At FD open,
sva_bind_device() is called which triggers a series of actions.</p>
<p>The example below is an illustration of <em>normal</em> operations that
involves <em>all</em> the SW components in VT-d. The flow can be simpler if
no ENQCMD is supported.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  VFIO        IOMMU        KVM        VDCM        IOASID       Ref
..................................................................
1             ioasid_register_notifier/_mm()
2 ioasid_alloc()                                               1
3 bind_gpasid()
4             iommu_bind()-&gt;ioasid_get()                       2
5             ioasid_notify(BIND)
6                          -&gt; ioasid_get()                     3
7                          -&gt; vmcs_update_atomic()
8 mdev_write(gpasid)
9                                    hpasid=
10                                   find_by_spid(gpasid)      4
11                                   vdev_write(hpasid)
12 -------- GUEST STARTS DMA --------------------------
13 -------- GUEST STOPS DMA --------------------------
14 mdev_clear(gpasid)
15                                   vdev_clear(hpasid)
16                                   ioasid_put()               3
17 unbind_gpasid()
18            iommu_ubind()
19            ioasid_notify(UNBIND)
20                          -&gt; vmcs_update_atomic()
21                          -&gt; ioasid_put()                     2
22 ioasid_free()                                                1
23            ioasid_put()                                      0
24                                                 Reclaimed
-------------- New Life Cycle Begin ----------------------------
1  ioasid_alloc()                                  -&gt;           1

Note: IOASID Notification Events: FREE, BIND, UNBIND
</pre></div>
</div>
<p>Exception cases arise when a guest crashes or a malicious guest
attempts to cause disruption on the host system. The fault handling
rules are:</p>
<ol class="arabic simple">
<li><p>IOASID free must <em>always</em> succeed.</p></li>
<li><p>An inactive period may be required before the freed IOASID is
reclaimed. During this period, consumers of IOASID perform cleanup.</p></li>
<li><p>Malfunction is limited to the guest owned resources for all
programming errors.</p></li>
</ol>
<p>The primary source of exception is when the following are out of
order:</p>
<ol class="arabic simple">
<li><p>Start/Stop of DMA activity
(Guest device driver, mdev via VFIO)</p></li>
<li><p>Setup/Teardown of IOMMU PASID context, IOTLB, DevTLB flushes
(Host IOMMU driver bind/unbind)</p></li>
<li><p>Setup/Teardown of VMCS PASID translation table entries (KVM) in
case of ENQCMD</p></li>
<li><p>Programming/Clearing host PASID in VDCM (Host VDCM driver)</p></li>
<li><p>IOASID alloc/free (Host IOASID)</p></li>
</ol>
<p>VFIO is the <em>only</em> user-kernel interface, which is ultimately
responsible for exception handling.</p>
<p>#1 is processed the same way as the assigned device today based on
device file descriptors and events. There is no special handling.</p>
<p>#3 is based on bind/unbind events emitted by #2.</p>
<p>#4 is naturally aligned with IOASID life cycle in that an illegal
guest PASID programming would fail in obtaining reference of the
matching host IOASID.</p>
<p>#5 is similar to #4. The fault will be reported to the user if PASID
used in the ENQCMD is not set up in VMCS PASID translation table.</p>
<p>Therefore, the remaining out of order problem is between #2 and
#5. I.e. unbind vs. free. More specifically, free before unbind.</p>
<p>IOASID notifier and refcounting are used to ensure order. Following
a publisher-subscriber pattern where:</p>
<ul class="simple">
<li><p>Publishers: VFIO &amp; IOMMU</p></li>
<li><p>Subscribers: KVM, VDCM, IOMMU</p></li>
</ul>
<p>IOASID reference must be acquired before receiving the FREE event. The
reference must be dropped at the end of the processing in order to
return the IOASID to the pool.</p>
<p>Let’s examine the IOASID life cycle again when free happens <em>before</em>
unbind. This could be a result of misbehaving guests or crash. Assuming
VFIO cannot enforce unbind-&gt;free order. Notice that the setup part up
until step #12 is identical to the normal case, the flow below starts
with step 13.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  VFIO        IOMMU        KVM        VDCM        IOASID       Ref
..................................................................
13 -------- GUEST STARTS DMA --------------------------
14 -------- *GUEST MISBEHAVES!!!* ----------------
15 ioasid_free()
16                                             ioasid_notify(FREE)
17                                             mark_free_pending (1)
18                          kvm_nb_handler(FREE)
19                          vmcs_update_atomic()
20                          ioasid_put_locked()   -&gt;           3
21                                   vdcm_nb_handler(FREE)
22            iomm_nb_handler(FREE)
23 ioasid_free() returns(2)          schedule_work()           2
24            schedule_work()        vdev_clear_wk(hpasid)
25            teardown_pasid_wk()
26                                   ioasid_put() -&gt;           1
27            ioasid_put()                                     0
28                                                 Reclaimed
29 unbind_gpasid()
30            iommu_unbind()-&gt;ioasid_find() Fails(3)
-------------- New Life Cycle Begin ----------------------------
</pre></div>
</div>
<p>Note:</p>
<ol class="arabic simple">
<li><p>By marking IOASID FREE_PENDING at step #17, no new references can be
held. ioasid_get/find() will return -ENOENT;</p></li>
<li><p>After step #23, all events can go out of order. Shall not affect
the outcome.</p></li>
<li><p>IOMMU driver fails to find private data for unbinding. If unbind is
called after the same IOASID is allocated for the same guest again,
this is a programming error. The damage is limited to the guest
itself since unbind performs permission checking based on the
IOASID set associated with the guest process.</p></li>
<li><p>Workqueues are used by VDCM and IOMMU driver for processing that
requires thread context.</p></li>
</ol>
<div class="section" id="kvm-pasid-translation-table-updates">
<h4><a class="toc-backref" href="#id21">KVM PASID Translation Table Updates</a><a class="headerlink" href="#kvm-pasid-translation-table-updates" title="Permalink to this headline">¶</a></h4>
<p>Per VM PASID translation table is maintained by KVM in order to
support ENQCMD in the guest. The table contains host-guest PASID
translations to be consumed by CPU ucode. The synchronization of the
PASID states depends on VFIO/IOMMU driver, where IOCTL and atomic
notifiers are used. KVM must register IOASID notifier per VM instance
during launch time. The following events are handled:</p>
<ol class="arabic simple">
<li><p>BIND/UNBIND</p></li>
<li><p>FREE</p></li>
</ol>
<p>Rules:</p>
<ol class="arabic simple">
<li><p>Multiple devices can bind with the same PASID, this can be different PCI
devices or mdevs within the same PCI device. However, only the
<em>first</em> BIND and <em>last</em> UNBIND emit notifications.</p></li>
<li><p>IOASID code is responsible for ensuring the correctness of H-G
PASID mapping. There is no need for KVM to validate the
notification data.</p></li>
<li><p>When UNBIND happens <em>after</em> FREE, KVM will see error in
ioasid_get() even when the reclaim is not done. IOMMU driver will
also avoid sending UNBIND if the PASID is already FREE.</p></li>
<li><p>When KVM terminates <em>before</em> FREE &amp; UNBIND, references will be
dropped for all host PASIDs.</p></li>
</ol>
</div>
<div class="section" id="vdcm-pasid-programming">
<h4><a class="toc-backref" href="#id22">VDCM PASID Programming</a><a class="headerlink" href="#vdcm-pasid-programming" title="Permalink to this headline">¶</a></h4>
<p>VDCM composes virtual devices and exposes them to the guests. When
the guest allocates a PASID then program it to the virtual device, VDCM
intercepts the programming attempt then programs the matching host
PASID on to the hardware.
Conversely, when a device is going away, VDCM must be informed such
that PASID context on the hardware can be cleared. There could be
multiple mdevs assigned to different guests in the same VDCM. Since
the PASID table is shared at PCI device level, lazy clearing is not
secure. A malicious guest can attack by using newly freed PASIDs that
are allocated by another guest.</p>
<p>By holding a reference of the PASID until VDCM cleans up the HW context,
it is guaranteed that PASID life cycles do not cross within the same
device.</p>
</div>
</div>
</div>
<div class="section" id="reference">
<h2><a class="toc-backref" href="#id23">Reference</a><a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://software.intel.com/sites/default/files/managed/c5/15/architecture-instruction-set-extensions-programming-reference.pdf">https://software.intel.com/sites/default/files/managed/c5/15/architecture-instruction-set-extensions-programming-reference.pdf</a></p></li>
<li><p><a class="reference external" href="https://01.org/blogs/2019/introducing-intel-data-streaming-accelerator">https://01.org/blogs/2019/introducing-intel-data-streaming-accelerator</a></p></li>
<li><p><a class="reference external" href="https://software.intel.com/en-us/download/intel-data-streaming-accelerator-preliminary-architecture-specification">https://software.intel.com/en-us/download/intel-data-streaming-accelerator-preliminary-architecture-specification</a></p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>